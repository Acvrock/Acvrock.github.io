<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Java 集合框架 | 静宏的 blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Apache Common Collections
Google Guava
Java Collections Framework

Collection
可遍历的、可伸缩的、可查询的，而可排序不是集合的要求
Iterator 设计模式解决无限的数据-&amp;gt; 有限的内存这个矛盾
PriorityQueue 优先队列，使用二叉堆实现,二叉堆又是用数组表示
BlockingQueue 堵塞队列，用">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合框架">
<meta property="og:url" content="http://www.Acvrock.com/2016/12/02/20161202_java_ collections/index.html">
<meta property="og:site_name" content="静宏的 blog">
<meta property="og:description" content="Apache Common Collections
Google Guava
Java Collections Framework

Collection
可遍历的、可伸缩的、可查询的，而可排序不是集合的要求
Iterator 设计模式解决无限的数据-&amp;gt; 有限的内存这个矛盾
PriorityQueue 优先队列，使用二叉堆实现,二叉堆又是用数组表示
BlockingQueue 堵塞队列，用">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161219-0@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161219-1@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161220-0@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161220-1@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/set.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161223-0@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161223-2@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161224-0@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161224-3@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/9Ete5.jpg">
<meta property="og:image" content="http://www.Acvrock.com/img/QQ20161224-1@2x.png">
<meta property="og:image" content="http://www.Acvrock.com/img/collection.png">
<meta property="og:updated_time" content="2017-01-22T14:23:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 集合框架">
<meta name="twitter:description" content="Apache Common Collections
Google Guava
Java Collections Framework

Collection
可遍历的、可伸缩的、可查询的，而可排序不是集合的要求
Iterator 设计模式解决无限的数据-&amp;gt; 有限的内存这个矛盾
PriorityQueue 优先队列，使用二叉堆实现,二叉堆又是用数组表示
BlockingQueue 堵塞队列，用">
<meta name="twitter:image" content="http://www.Acvrock.com/img/QQ20161219-0@2x.png">
  
    <link rel="alternative" href="/atom.xml" title="静宏的 blog" type="application/atom+xml">
  
  
    <!-- <link rel="icon" href="//favicon.ico"> -->
    <link rel="icon" href="/favicon.ico">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/develop-web.png" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">静宏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">垂死病中惊卧起，谈笑风生又一年</p>
		

		<nav class="header-menu">
			<ul>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Acvrock" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/jinghong1994/" title="weibo">weibo</a>
		        
					<a class="twitter" target="_blank" href="https://twitter.com/li1215101" title="twitter">twitter</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">静宏</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/develop-web.png" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">静宏</h1>
			</hgroup>
			
			<p class="header-subtitle">垂死病中惊卧起，谈笑风生又一年</p>
			
			<nav class="header-menu">
				<ul>
				
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Acvrock" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/jinghong1994/" title="weibo">weibo</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/li1215101" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-20161202_java_ collections" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 集合框架
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Apache Common Collections</li>
<li>Google Guava</li>
<li>Java Collections Framework</li>
</ul>
<p>Collection
可遍历的、可伸缩的、可查询的，而可排序不是集合的要求<br>
Iterator 设计模式解决无限的数据-&gt; 有限的内存这个矛盾</p>
<p>PriorityQueue 优先队列，使用二叉堆实现,二叉堆又是用数组表示<br>
BlockingQueue 堵塞队列，用于生产者消费者模式<br>
HashMap 内部为一个 Tree 实现<br>
如果以插入+查找最小+删除最小来比较红黑树和最小堆时，红黑树占优<br>
JDK 8 中，HashMap Hash 冲突时，使用红黑树代替链表</p>
<p>java.lang.ref.SoftReference     软引用<br>
java.lang.ref.WeakReference     弱引用<br>
java.lang.ref.PhantomReference  虚引用<br>
WeakHashMap<br>
SkipList 跳表   ConcurrentSkipListMap  空间换时间<br>
树为了排序</p>
<h2>实践</h2>
<ul>
<li>定义时使用接口</li>
<li>底层返回集合为空时，返回长度为 0 的集合或者数组，不要返回 null</li>
<li>谨慎对待 hashCode 和 equals</li>
<li>用 Arrays 和 Collections 处理：排序、查找、集合类型转换、集合计算操作</li>
<li>如果元素长度固定，优先考虑 Array</li>
<li>使用泛型</li>
<li>遍历 List 时，考虑使用 ListIterator</li>
<li>频繁查找某个元素时，考虑进行排序</li>
<li>需要元素有序时，考虑使用 Linked 家族</li>
<li>使用 WeakHashMap 维护短暂使用的数据</li>
<li>多线程环境下优先使用 concurrent 家族</li>
<li>多线程环境下频繁遍历少量修改，考虑 CopyOnWriteArrayList</li>
<li>多线程环境下不要强一致性的遍历器，可考虑使用 ConcurrentHashahMap</li>
<li>多线程环境下使用 TreeMap ，考虑 ConcurrentSkipListSet 和 ConcurrentSkipListMap</li>
</ul>
<h2>QA</h2>
<p>1 分析Collection接口以及其子接口，很通俗的方式说说，究竟有哪些类型的Collection，各自解决什么样的问题
Collection 接口关系如图<br>
<img src="/img/QQ20161219-0@2x.png" alt=""><br>
三个子接口分别是: Queue、Set、List,还有一个抽象类 AbstractCollection,
Collection 接口抽象了一组元素的集合，提供了通用的集合操作方法
<img src="/img/QQ20161219-1@2x.png" alt=""></p>
<ul>
<li>其中 Set 代表无序，不可重复的集合，就像是一个盘子里的小石头，每个都一样是石头，但是每一个形状又都不一样，Set 的 API 和 Collection 完全一样;</li>
<li>List 代表有序，可重复的集合，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1，对比 Collection，List 拓展了自己的方法，增加了 “添加、删除、获取、修改指定位置的元素”、“获取List中的子队列” 等方法;<br>
<img src="/img/QQ20161220-0@2x.png" alt=""></li>
<li>Queue 代表一种队列集合，队列的头部保存在队列中存放时间最长的元素，尾部保存存放时间最短的元素。新元素插入到队列的尾部，取出元素会返回队列头部的元素，对比 Collection 接口，Queue 增加了&quot;队尾元素插入&quot;，&quot;获取队头元素&quot; 等方法
<img src="/img/QQ20161220-1@2x.png" alt=""></li>
<li>AbstractCollection 是一个抽象类，它实现了 Collection 中除 iterator() 和 size() 之外的函数。
AbstractCollection 的主要作用：它实现了 Collection 接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。</li>
</ul>
<p>2 TreeSet继承了什么Set，与HashSet的区别是？HashSet与HashTable是“一脉相承”的么？
TreeSet 和 HashSet 类图如下:
<img src="/img/set.png" alt="">
可以看到，TreeSet 和 HashSet 都继承了 AbstractSet，都实现了 Serializable、Cloneable 接口，但是对于 HashSet 来说，TreeSet 实现了 NavigableSet、SortedSet 接口
SortedSet 具有排序功能，它支持对 Set 中的元素排序，提供了三大功能，分别是</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123;</div><div class="line">    // Range-view 范围查看 </div><div class="line">    SortedSet&lt;E&gt; subSet(E fromElement, E toElement);</div><div class="line">    SortedSet&lt;E&gt; headSet(E toElement);</div><div class="line">    SortedSet&lt;E&gt; tailSet(E fromElement);</div><div class="line"></div><div class="line">    // Endpoints  端点</div><div class="line">    E first();</div><div class="line">    E last();</div><div class="line"></div><div class="line">    // Comparator access  访问 Comparator</div><div class="line">    Comparator&lt;? super E&gt; comparator();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NavigableSet  直译成中文就是：可导航的 Set,是 SortedSet 的子接口，有 ConcurrentSkipListSet, TreeSet 两种实现<br>
增加了返回小于（lower）、小于等于（floor）、大于等于（ceiling）和大于（higher）输入参数的一个元素的方法<br>
弹出第一个(pollFirst)，最后一个元素(pollLast)、<br>
以及正向和逆向的迭代器、<br>
返回更小的元素集合(headSet)，更大的元素集合(tailSet)，区间元素集合(subSet)
<img src="/img/QQ20161223-0@2x.png" alt=""></p>
<p>HashSet与HashTable 不是是“一脉相承”的，因为 HashSet 实现了 Set 接口，HashTable 实现了 Map 接口</p>
<p>3 Queue接口增加了哪些方法，这些方法的作用和区别是？<br>
Queue 本质上是一个操作受限的集合，结构图如下：<br>
<img src="/img/QQ20161223-2@2x.png" alt=""></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">offer       添加一个元素并返回插入结果,优于add，因为如果队列已满，则返回false，不抛出异常  </div><div class="line">remove   	 移除并返回队列头部的元素， 如果队列为空，则抛出一个异常   </div><div class="line">poll        移除并返问队列头部的元素，优于remove,因为如果队列为空，则返回null   </div><div class="line">element     返回队列头部的元素，如果队列为空，则抛出一个异常      </div><div class="line">peek        返回队列头部的元素，优于peek,因为如果队列为空，则返回null</div></pre></td></tr></table></figure></p>
<p>4 LinkedList也是一种Queue么？是否是双向链表?<br>
LinkedList 实现了 Queue 接口，所以可以作为队列，作为 FIFO 的队列时，下表的方法等价：</p>
<table>
<thead>
<tr>
<th>队列方法</th>
<th>等效方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
<p>LinkedList 是双向链表实现，从下图可以看出，它分别记录了头节点和尾节点，便于双向遍历<br>
<img src="/img/QQ20161224-0@2x.png" alt=""><br>
5 Java数组如何与Collection相互转换</p>
<ul>
<li>Collection to Array:</li>
</ul>
<ol>
<li>Bar[] result = foos.stream().map(Bar::new).toArray(Bar[]::new);</li>
<li>Foo[] foos = x.toArray(new Foo[x.size()]);</li>
<li>int i = 0;<br>
Bar[] bars = new Bar[fooCollection.size()];
for( Foo foo : fooCollection ) { // where fooCollection is Collection&lt;Foo&gt; bars[i++] = new Bar(foo);
}</li>
</ol>
<ul>
<li>Array to Collection:</li>
</ul>
<ol>
<li>XXX xxx = new XXX(Arrays.asList(array));</li>
<li>Collections.addAll(list, array);</li>
<li>XXX xxx = Arrays.stream(array).collect(Collectors.toXXX());</li>
</ol>
<p>6 Map的一级子接口有哪些种类，分别用作什么目的？<br>
下图为 Map 实现类和子接口
<img src="/img/QQ20161224-3@2x.png" alt=""><br>
子接口有：<br>
Bindings,      不明
ConcurrentMap&lt;K,V&gt;,   定义了几个基于 CAS（Compare and Set）操作
MessageContext,   不明<br>
ObservableMap,   允许注册观察者跟踪 Map 值的更改<br>
SortedMap&lt;K,V&gt;    可进行排序的 Map<br>
XSNamedMap,      为内部使用的接口，不明<br>
7 HashSet 与HashMap中放入的自定义对象必须要实现哪些方法，说明原因<br>
如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。<br>
8 TreeSet里的自定义对象必须要实现什么方法，说明原因<br>
因为 TreeSet 具有排序功能，所以对象集合必须实现Comparable接口,并重写compareTo()方法，通常我们需要保持 compareTo 和 equals 同步，所以最好也实现 equalse 方法<br>
9 LinkedHashMap使用什么来保存数据，其效率与HashMap相比如何？它又有什么独特特性<br>
LinkedHashMap 继承了 HashMap ，所以底层使用了数组来保存数据，用 set 来保存 key 集合，但是它又新增了 head 和 tail 实现双向循环链表，下面是开销情况：
<img src="/img/9Ete5.jpg" alt=""><br>
对比 HashMap Hash的无序性，LinkedHashMap 的元素可以按插入顺序或访问顺序排列</p>
<p>10 IdentityHashMap 里面如果按照下面的方法放入对象，分别是什么结果，请解释原因</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> Integer a=5;</div><div class="line"> Integer b=5;</div><div class="line"> map.put(a,&quot;100&quot;);</div><div class="line"> map.put(b,&quot;100&quot;;</div><div class="line"> System.out.println(map.size);</div><div class="line"> map.clear();</div><div class="line">Integer a=Integer.MAX_VALUE-1;</div><div class="line">Integer b=Integer.MAX_VALUE-1;</div><div class="line">map.put(a,&quot;100&quot;);</div><div class="line"> map.put(b,&quot;100&quot;;</div><div class="line"> System.out.println(map.size);</div></pre></td></tr></table></figure></p>
<p>结果如图:
<img src="/img/QQ20161224-1@2x.png" alt=""><br>
原因是：是 IdentityHashMap 使用的是==比较key的值，调用 Integer.valueOf, 当值小于 127 时，返回的都是 IntegerCache 的值，所以 IdentityHashMap 认为它是同一个 key ，128 开始就返回一个新的 Integer, IdentityHashMap就认为不相等了</p>
<p>加分题，
给出ＪＤＫ　１.８的java 集合框架全图谱（Class类图）， 并标明1.7与1.8里出现的新的类，解释其目的<br>
下图为集合框架（非并发）
<img src="/img/collection.png" alt=""></p>
<ul>
<li>
<p>Iterator。它是遍历集合的工具，我们经常使用Iterator迭代器来遍历集合。Collection的实现类都要实现iterator()函数，返回一个Iterator对象。</p>
</li>
<li>
<p>Collection是一个interface<br>
Collection有List、Set和Queue三大分支。</p>
<ul>
<li>
<p>List&lt;E&gt;是一个队列，根据下标索引，第一个元素的下标是0，List的实现类有LinkedList, ArrayList, Vector, Stack。List是有序的队列，List中可以有重复的值。</p>
</li>
<li>
<p>Set&lt;E&gt;是一个集合，SET中的值是唯一的，我们经常会遇到List去重的问题，把List转为SET就可以快速实现 Set的实现类有HastSet和TreeSet。HashSet。其中TreeSet是有序的。</p>
</li>
<li>
<p>Queue 代表一种队列集合，队列的头部保存在队列中存放时间最长的元素，尾部保存存放时间最短的元素。新元素插入到队列的尾部，取出元素会返回队列头部的元素</p>
</li>
</ul>
</li>
<li>
<p>Map&lt;K,V&gt;是一个interface，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。</p>
<ul>
<li>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。</li>
</ul>
</li>
<li>
<p>抽象类AbstractCollection、AbstractList、AbstractSet、AbstractMap是抽象类，他们都实现了各自的大部分方法，我们直接继承Abstract类就可以省去重复编码相同的方法</p>
</li>
<li>
<p>List简介</p>
</li>
</ul>
<ol>
<li>List 是一个接口，它继承于Collection的接口。它代表着有序的队列。</li>
<li>AbstractList 是一个抽象类，它继承于AbstractCollection。AbstractList实现List接口中除size()、get(int location)之外的函数。</li>
<li>AbstractSequentialList 是一个抽象类，它继承于AbstractList。AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”。</li>
<li>ArrayList, LinkedList, Vector, Stack, 是List的4个实现类,RandomAccessSubList是内部类。</li>
</ol>
<ul>
<li>Map体系</li>
</ul>
<ol>
<li>Map 是映射接口，Map中存储的内容是键值对(key-value)。</li>
<li>AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li>
<li>SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。</li>
<li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如&quot;获取大于/等于某对象的键值对&quot;、“获取小于/等于某对象的键值对”等等。</li>
<li>TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”， 它是通过红黑树实现的。它一般用于单线程中存储有序的映射。</li>
<li>HashMap 继承于AbstractMap，没实现SortedMap或NavigableMap接口；因此，HashMap的内容是无序的键值对。</li>
<li>LinkedHashMap 继承于HashMap，LinkedHashMap 的元素可以按插入顺序或访问顺序排列</li>
<li>IdentityHashMap 是 1.4 版本新增的一种特殊的HashMap，还是用key的hashCode来决定entry的槽位，但是不用key的equals方法来决定是否相等了，而是默认使用地址（即使实现了equals，equals也不起作用）来决定是否相等</li>
<li>EnumMap 是 1.5 版本新增的一种键为枚举类型的特殊的Map实现。所有的Key也必须是一种枚举类型，EnumMap是使用数组来实现的。</li>
<li>Hashtable继承于Dictionary(Dictionary也是键值对的接口)，实现Map接口；因此，Hashtable的内容也是“键值对，是无序的”。 Hashtable是线程安全的。</li>
<li>WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”， 当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除。JVM提供的弱引用</li>
</ol>
<ul>
<li>Set简介</li>
</ul>
<ol>
<li>Set 是继承于Collection的接口。它是一个不允许有重复元素的集AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。</li>
<li>HashSet 和 TreeSet 是Set的两个实现类。HashSet中的元素是无序的。TreeSet中的元素是有序的，不支持快速随机遍历，只能通过迭代器进行遍历。</li>
<li>LinkedHashSet继承于 HashSet ,它以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；</li>
<li>EnumSet 是 enum 值的集合。在 Java 中，每个 enum 都映射至一个 int 类型：每个 enum 值映射的 int 都互不相同。这使得 BitSet 之类的集合结构成为可能，每个 bit 都映射到一个不同的 enum 值。此类还存在两种实现——包含单个 long 类型（可存储64个 enum 值，足够覆盖99.9%的用例）的 RegularEnumSet 与包含 long[] 类型的 JumboEnumSet</li>
</ol>
<ul>
<li>Queues(队列)/deques(双队列)</li>
</ul>
<ol>
<li>AbstractQueue 是继承于Queue的抽象类，它实现了Queue中的大部分API。其它Queue的实现类可以通过继承AbstractQueue来减少重复编码</li>
<li>PriorityQueue 继承 AbstractQueue ，是一个基于优先级堆的极大优先级队列。</li>
<li>ArrayDeque 基于数组的双端队列</li>
</ol>
<p>并发的集合有点乱...</p>
<p><a href="http://www.cnblogs.com/skywang12345/p/3308513.html#a4" target="_blank" rel="external">Java 集合系列02之 Collection架构</a><br>
<a href="http://www.importnew.com/19892.html" target="_blank" rel="external">Java HashSet和HashMap源码剖析</a><br>
<a href="http://stackoverflow.com/questions/2889777/difference-between-hashmap-linkedhashmap-and-treemap" target="_blank" rel="external">Difference between HashMap, LinkedHashMap and TreeMap</a><br>
<a href="https://my.oschina.net/oneapmofficial/blog/673984" target="_blank" rel="external">Java 性能调优指南之 Java 集合概览</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/02/20161202_java_ collections/" class="archive-article-date">
  	<time datetime="2016-12-02T15:04:30.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/12/10/java_byte/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Java 中的基本数据类型
        
      </div>
    </a>
  
  
    <a href="/2016/12/01/20161201_java_io/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java IO 编码解码</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>








<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="20161202_java_ collections" data-title="Java 集合框架" data-url="http://www.Acvrock.com/2016/12/02/20161202_java_ collections/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"acvrock"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//blog.acvrock.com/js/src/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 静宏 <a href="http://www.miitbeian.gov.cn/">粤ICP备16064340号-1</a>
    	</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      	<div class="footer-right">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
   <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/tags/Centos/" style="font-size: 10px;">Centos</a> <a href="/tags/Cronolog/" style="font-size: 10px;">Cronolog</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/Log/" style="font-size: 10px;">Log</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/checkbox-padding兼容/" style="font-size: 10px;">checkbox padding兼容</a> <a href="/tags/log4j2/" style="font-size: 10px;">log4j2</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a> <a href="/tags/－-总结/" style="font-size: 13.33px;">－ 总结</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">生命不息&lt;/br&gt;冲锋不止!</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>